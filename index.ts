import express from 'express';
import { createServer } from 'http';
import { Server as SocketServer } from 'socket.io';
import { fork, exec, ChildProcess } from 'child_process';
import logger from './utils/logger';

let gpsProcess: ChildProcess | null = null;
let gpsData: GpsProcessSyncData;
let lastGpsUpdate = 0;
let gpsUpdateScheduled = false;

// Wrap everything in async function for proper await handling
const main = async (): Promise<void> => {
  // Output logger level
  logger.info(`LOG LEVEL: ${logger.level}`);

  // Connect gps process
  createGpsProcess();

  // Setup Express
  setupWebServer();

  // If process forcibly terminated - clear out
  process.on('SIGTERM', () => {
    server.close();
  });

};

const expressServer = express();
const server = createServer(expressServer);
const webServerSocket = new SocketServer(server);  // Instantiate Socket.IO server

const setupWebServer = (): void => {
  expressServer.get('/', (_, res) => {
    res.sendFile(__dirname + '/static/index.html');
  });

  expressServer.get('/chat', (_, res) => {
    res.sendFile(__dirname + '/static/chat.html');
  });

  // Starting listening for server
  server.listen(3000, () => {
    logger.info('listening on *:3000');
  });

  // Websocket connection made
  webServerSocket.on('connection', (webSocket) => {
    logger.info('UI user connected(new socket created)');

    webSocket.on('disconnect', () => logger.info('UI user disconnected'));

    webSocket.on('chat message', (msg: string) => {
      logger.info('message: ' + msg);

      // mirror message back to user
      webServerSocket.emit('chat message', msg);

      if (gpsProcess && msg === 'gps off') gpsProcess.send(msg);
      if (gpsProcess && msg === 'gps on') gpsProcess.send(msg);
    });

    webSocket.on('RESTART_SURVEY', (params: string) => gpsProcess && !gpsProcess.killed && gpsProcess.send('RESTART_SURVEY:' + params));
    webSocket.on('RESTART_FIXED', (params: string) => gpsProcess && !gpsProcess.killed && gpsProcess.send('RESTART_FIXED:' + params));

    webSocket.on('POWER_OFF', () => exec('shutdown now', (error, stdout, stderr) => logger.info('shutting down....')));
    webSocket.on('REBOOT', () => exec('shutdown -r now', (error, stdout, stderr) => logger.info('rebooting....')));

    // RTCM TEST
    webSocket.on('rtcm', (rtcmData: string) => {
      logger.info('RTCM: ' + rtcmData);
    });
  });
};

const createGpsProcess = (): void => {
  gpsProcess = fork('build/gps.js', logger.level === 'debug' ? ['--debug'] : []);

  // Getting coordinate data from GPS
  gpsProcess.on('message', (data: any) => {
    gpsData = data;

    if (data.error) {
      logger.error('error generated by gps process: ' + data.error);
    }

    const now = Date.now();
    const timeSinceLastUpdate = now - lastGpsUpdate;

    if (timeSinceLastUpdate >= 1000) {
      // If at least 1 second has passed, send immediately
      sendGpsUpdate();
    } else if (!gpsUpdateScheduled) {
      // Schedule the next update if not already scheduled
      gpsUpdateScheduled = true;
      setTimeout(sendGpsUpdate, 1000 - timeSinceLastUpdate);
    }
  });

  // Restart GPS process if it exits
  gpsProcess.on('exit', (code: number) => {
    logger.info('Gps process exited with code ' + code + '. Trying to restart...');
    createGpsProcess();
  });
};

// Update browser
const sendGpsUpdate = () => {
  webServerSocket.emit('SENSOR_DATA', { gps: gpsData });
  lastGpsUpdate = Date.now();
  gpsUpdateScheduled = false;
};

main();