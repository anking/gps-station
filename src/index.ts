import express from 'express';
import { createServer } from 'http';
import { Server as SocketServer } from 'socket.io';
import { fork, exec, ChildProcess, spawn } from 'child_process';
import logger from './utils/logger';
import { config } from './config';

let gpsProcess: ChildProcess | null = null;
let gpsData: GpsProcessSyncData;
let lastGpsUpdate = 0;
let gpsUpdateScheduled = false;
const webServerUrl = `http://localhost:${config.webServerPort}`;
let browserProcess: any = null;

const expressServer = express();
const server = createServer(expressServer);
const webServerSocket = new SocketServer(server);  // Instantiate Socket.IO server

// Wrap everything in async function for proper await handling
const main = async (): Promise<void> => {
  // Output logger level
  logger.info(`Log level: ${logger.level}`);

  // Connect gps process
  createGpsProcess();

  // Start browser on RPi
  startBrowser();

  // Setup Express
  setupWebServer();

  process.on('SIGINT', () => {
    logger.info('Shutting down the server...');
    shutdownBrowser();
    process.exit();
  });

  process.on('SIGTERM', () => {
    logger.info('Shutting down the server...');
    server.close();
    shutdownBrowser();
    process.exit();
  });
};

const setupWebServer = (): void => {
  expressServer.get('/', (_, res) => {
    res.sendFile(__dirname + '/static/index.html');
  });

  expressServer.get('/chat', (_, res) => {
    res.sendFile(__dirname + '/static/chat.html');
  });

  // API route to expose environment variable
  expressServer.get('/config', (_, res) => {
    res.json({ googleMapsApiKey: config.googleMapsApiKey });
  });

  // Starting listening for server
  server.listen(config.webServerPort, () => {
    logger.info(`listening on *:${config.webServerPort}`);
  });

  // Websocket connection made
  webServerSocket.on('connection', (webSocket) => {
    logger.info('UI user connected(new socket created)');

    webSocket.on('disconnect', () => logger.info('UI user disconnected'));

    webSocket.on('chat message', (msg: string) => {
      logger.info('message: ' + msg);

      // mirror message back to user
      webServerSocket.emit('chat message', msg);

      if (gpsProcess && msg === 'gps off') gpsProcess.send(msg);
      if (gpsProcess && msg === 'gps on') gpsProcess.send(msg);
    });

    webSocket.on('RESTART_SURVEY', (params: string) => gpsProcess && !gpsProcess.killed && gpsProcess.send('RESTART_SURVEY:' + params));
    webSocket.on('RESTART_FIXED', (params: string) => gpsProcess && !gpsProcess.killed && gpsProcess.send('RESTART_FIXED:' + params));

    webSocket.on('POWER_OFF', () => handleSystemCommand('sudo shutdown now', 'Shutting down'));
    webSocket.on('REBOOT', () => handleSystemCommand('sudo shutdown -r now', 'Rebooting'));

    // RTCM TEST
    webSocket.on('rtcm', (rtcmData: string) => {
      logger.info('RTCM: ' + rtcmData);
    });
  });
};

// Start Chromium in kiosk mode when the server starts
const startBrowser = () => {
  logger.chromium("Starting up browser...");

  // Set the DISPLAY environment variable to :0
  process.env.DISPLAY = ":0";

  browserProcess = spawn("chromium-browser", [
    "--no-sandbox",
    "--disable-gpu",
    "--kiosk",
    "--disable-infobars",
    "--disable-session-crashed-bubble",
    "--noerrdialogs",
    webServerUrl
  ], {
    detached: false,  // Don't detach so that we can manage the process
    stdio: ["ignore", "pipe", "pipe"]  // Capture stdout and stderr
  });

  browserProcess.stdout.on('data', (data: Buffer) => {
    // Log stdout with your desired formatting (e.g., prepend with [STDOUT])
    logger.chromium(data.toString());
  });

  browserProcess.stderr.on('data', (data: Buffer) => {
    // Log stderr with your desired formatting (e.g., prepend with [STDERR])
    logger.error(`[CR] ${data.toString()}`);
  });

  browserProcess.on('error', (err: any) => {
    logger.error("Failed to start browser:", err);
  });

  browserProcess.on('exit', (code: number) => {
    logger.error(`Chromium exited with code: ${code}`);
  });
};

// Gracefully shut down and close the browser
const shutdownBrowser = () => {
  if (browserProcess) {
    logger.chromium("Shutting down the browser...");
    browserProcess.kill();  // Send termination signal to the browser process
  }
};

const createGpsProcess = (): void => {
  gpsProcess = fork('build/gps.js', logger.level === 'debug' ? ['--debug'] : []);

  // Getting coordinate data from GPS
  gpsProcess.on('message', (data: any) => {
    gpsData = data;

    if (data.error) {
      logger.error('error generated by gps process: ' + data.error);
    }

    const now = Date.now();
    const timeSinceLastUpdate = now - lastGpsUpdate;

    if (timeSinceLastUpdate >= 1000) {
      // If at least 1 second has passed, send immediately
      sendGpsUpdate();
    } else if (!gpsUpdateScheduled) {
      // Schedule the next update if not already scheduled
      gpsUpdateScheduled = true;
      setTimeout(sendGpsUpdate, 1000 - timeSinceLastUpdate);
    }
  });

  // Restart GPS process if it exits
  gpsProcess.on('exit', (code: number) => {
    logger.info('Gps process exited with code ' + code + '. Trying to restart...');
    createGpsProcess();
  });
};

// Update browser
const sendGpsUpdate = () => {
  webServerSocket.emit('SENSOR_DATA', { gps: gpsData });
  lastGpsUpdate = Date.now();
  gpsUpdateScheduled = false;
};

// Helper function to handle system commands
const handleSystemCommand = (command: string, action: string) => {
  exec(command, (error, stdout, stderr) => {
    if (error) {
      logger.error(`Error during ${action}: ${error.message}`);
      return;
    }
    if (stderr) {
      logger.error(`stderr during ${action}: ${stderr}`);
      return;
    }
    logger.info(`${action} completed successfully: ${stdout}`);
  });
};

main();